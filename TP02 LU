{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Décomposition $LU$ d'une matrice\n",
    "\n",
    "Dans ce TP, nous allons programmer l'algorithme de décomposition $LU$ d'une matrice."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import numpy.random as rd\n",
    "import matplotlib.pyplot as plt\n",
    "import sys\n",
    "import time\n",
    "\n",
    "%matplotlib inline\n",
    "%config InlineBackend.figure_format = 'retina'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Intérêt de la décomposition\n",
    "\n",
    "Commençons par justifier l'utilisation de cette décomposition. Nous savons que la résolution d'un système linéaire $Ax=b$ est toujours possible dès que la matrice $A$ est inversible en utilisant les formules de Cramer. Ces formules nécessitent de calculer $n+1$ déterminants de taille $n{\\times}n$. \n",
    "\n",
    "Si le calcul des déterminants est fait en utilisant la méthode de développement par rapport aux lignes (ou aux colonnes, c'est pareil), l'algorithme de calcul est récursif et il faut de l'ordre de $n!$ opérations pour calculer un déterminant de taille $n{\\times}n$. \n",
    "\n",
    "Faisons un rapide calcul pour évaluer le temps nécessaire au déterminant d'une matrice pleine de taille $n$.\n",
    "\n",
    "#### Question 1\n",
    "\n",
    "Supposons que nous puissions faire le calcul sur l'ordinateur le plus puissant du monde (actuellement c'est _TaihuLight_ https://fr.wikipedia.org/wiki/TOP500) capable de faire $125{\\times}10^{15}$ opérations par secondes. \n",
    "\n",
    "> \n",
    "* Calculez le temps nécessaire au calcul d'un déterminant de taille 20, 25, 30, 35, 40, 45, 50 (affichez le précisément en années, jours, heures, minutes, secondes). \n",
    "* Que constatez-vous ?\n",
    "* Essayez de formater vos résultats ainsi    \n",
    "    > `n = 20 ->  19s   0m   0h   0j  0.000e+00 a`\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "n =  20  ->  19  s  0.0  m  0.0  h  0.0  j  0.0  a \n",
      "n =  25  ->  20  s  21.0  m  5.0  h  341.0  j  3.0  a \n",
      "n =  30  ->  48  s  38.0  m  14.0  h  22.0  j  67288904.0  a \n",
      "n =  35  ->  33  s  44.0  m  8.0  h  18.0  j  2621295780412518.0  a \n",
      "n =  40  ->  48  s  0.0  m  8.0  h  294.0  j  2.069800312653216e+23  a \n",
      "n =  45  ->  55  s  0.0  m  0.0  h  54.0  j  3.0345565922242566e+31  a \n",
      "n =  50  ->  51  s  8.0  m  0.0  h  224.0  j  7.715396550409279e+39  a \n"
     ]
    }
   ],
   "source": [
    "def Temps(n):\n",
    "    a = (np.math.factorial(n)//(125*10**15))\n",
    "    s = a%60\n",
    "    M = ((a-s)/60)\n",
    "    m = M%60\n",
    "    H = (M - m)/60\n",
    "    h = H % 24\n",
    "    J = (H - h)/24\n",
    "    j = J % 365\n",
    "    a = (J-j)/365\n",
    "\n",
    "    print(\"n = \",n,\" -> \",s,\" s \",m,\" m \",h,\" h \",j,\" j \",a,\" a \")\n",
    "    \n",
    "    \n",
    "Temps(20)\n",
    "Temps(25)\n",
    "Temps(30)\n",
    "Temps(35)\n",
    "Temps(40)\n",
    "Temps(45)\n",
    "Temps(50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Rappelons que la décomposition $LU$ d'une matrice carrée de taille $n$ est l'écriture\n",
    "$$ A = LU,$$\n",
    "où la matrice $A$ est triangulaire inférieure (pour _low_) avec que des 1 sur la diagonale et où $U$ est triangulaire supérieure (pour _up_) avec des éléments diagonaux non nuls.\n",
    "\n",
    "Un résultat essentiel est que cette décomposition $LU$ n'existe pas toujours et plus précisément, cette décomposition existe si, et seulement si, tous les mineurs principaux de la matrice sont non nuls (condition invérifiable en pratique).\n",
    "Dans ce cas, on dit de la matrice qu'elle est _complètement régulière_. L'ensemble des matrices d'ordre $n$ complètement régulières est noté $\\Lambda_n(\\mathbb{R})$. \n",
    "\n",
    "Cette décomposition sous forme de produit de matrices triangulaires est très utile pour résoudre un système linéaire. En effet, si $A = LU$, la résolution de $Ax=b$ se fait en deux étapes : \n",
    "* on commence par résoudre $Ly = b$ \n",
    "* on termine en résolvant $Ux = y$.\n",
    "\n",
    "Chacun de ces problèmes étant beaucoup moins couteux que lorsque la matrice $A$ est pleine, la décomposition $LU$ est une manière efficace pour résoudre les systèmes linéaires.\n",
    "\n",
    "Notons également une seconde application : le calcul d'un déterminant. Nous savons que l'utilisation des formules de Cramer pour calculer un déterminant est une opération bien trop couteuse. Lorsque la décomposition $LU$ de la matrice est connue, le déterminant se calcule très rapidement comme le produit des éléments diagonaux de la matrice $U$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Approche récursive\n",
    "\n",
    "Pour obtenir la factorisation $LU$ d'une matrice $A\\in\\Lambda_n(\\mathbb{R})$ donnée, \n",
    "on peut utiliser une décomposition par blocs et procéder par récurrence.\n",
    "\n",
    "#### Cas $n=1$.\n",
    "\n",
    "La décomposition est triviale... Quelles sont alors les matrices $L$ et $U$ ?\n",
    "\n",
    "#### Cas $n>1$.\n",
    "\n",
    "Puisque $n\\geq 2$, il est possible d'écrire la matrice $A$ par blocs \n",
    "$$\n",
    "A = \\begin{pmatrix}\n",
    "a & b \\\\\n",
    "c & A'\n",
    "\\end{pmatrix}\n",
    "\\,,\n",
    "$$\n",
    "de sorte que \n",
    "$a$ est un réel, $b$ une matrice ligne, $c$ une matrice colonne et $A'$ une matrice carrée de $\\in\\mathcal{M}_{n-1}(\\mathbb{R})$.\n",
    "Ecrivons de même la factorisation recherchée sous la forme \n",
    "$$\n",
    "LU = \\begin{pmatrix}\n",
    "1 & 0 \\\\\n",
    "l & L'\n",
    "\\end{pmatrix}\\begin{pmatrix}\n",
    "\\alpha & u \\\\ 0 & U'\n",
    "\\end{pmatrix}\n",
    "\\,,$$\n",
    "avec des matrices $L', U'\\in\\mathcal{M}_{n-1}(\\mathbb{R})$ respectivement triangulaire inférieure à coefficients diagonaux $=1$ et triangulaire supérieure. L'égalité $A = LU$ devient alors\n",
    "$$\n",
    "\\begin{pmatrix}\n",
    "a & b \\\\\n",
    "c & A'\n",
    "\\end{pmatrix}\n",
    "= \\begin{pmatrix}\n",
    "\\alpha & u \\\\\n",
    "\\alpha l & l u + L' U'\n",
    "\\end{pmatrix}\n",
    "\\,.\n",
    "$$\n",
    "Nous remarquons que le produit $lu$ d'une matrice colonne par une matrice ligne est bien égal à une matrice carrée de taille $n{-}1$, comme le produit $L'U'$.\n",
    "\n",
    "Ceci conduit à la résolution d'un système de quatre équations matricielles\n",
    "\n",
    "$$\n",
    "\\left\\{\\begin{aligned}\n",
    "a & = \\alpha \\,,\\\\\n",
    "b & = u \\,,\\\\\n",
    "c & = \\alpha l\\,,\\\\\n",
    "A' & = lu + L' U'\\,.\n",
    "\\end{aligned}\\right.\n",
    "$$\n",
    "\n",
    "Par hypothèse, $A$ est inversible donc la matrice $U$ doit l'être aussi et la condition $\\alpha \\neq 0$ est vérifiée. Le système impose alors successivement les valeurs de $\\alpha$, $u$ et $l$ \n",
    "en fonction des données $a$, $b$ et $c$. \n",
    "Reste alors à résoudre\n",
    "\n",
    "$$\n",
    "A' - a^{-1}cb = L'U'\\,.\n",
    "$$\n",
    "\n",
    "Puisque $L'$ et $U'$ héritent des propriétés de $L$ et $U$, \n",
    "on est ramené à trouver la factorisation $LU$ d'une matrice d'ordre $n-1$. \n",
    "\n",
    "#### En pratique\n",
    "\n",
    "On souhaite gérer le cas d'une matrice dont on ne sait pas à l'avance si elle est inversible et/ou possède une factorisation $LU$ : l'algorithme peut donc échouer, soit parce que le coefficient $a$ est nul, soit parce que la matrice $A - a^{-1}cb$ n'a pas de factorisation $LU$. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La récurrence ci-dessus se prête naturellement à une mise en oeuvre par récursivité. \n",
    "\n",
    "#### Question 2\n",
    "\n",
    "> Programmez une fonction récursive `lu` qui prend en argument une matrice $A$ et qui retourne la matrice $L$ et la matrice $U$ de la décomposition $LU$ de $A$ ainsi qu'un booléen qui est vrai si la décomposition est réussie et faux dans le cas contraire. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "def lu(A):\n",
    "    n = np.shape(A)[0]\n",
    "    L = np.eye(n)\n",
    "    U = np.zeros((n,n))\n",
    "    taille = np.shape(A)\n",
    "    if(np.size(A) == 1):\n",
    "        if(A[0]==0):\n",
    "            print(\"Matrice taille 1 de coef nul\")\n",
    "            return L,U,False\n",
    "        L = 1 \n",
    "        U = A\n",
    "        #print(\"ICIII\")\n",
    "        return L,U,True\n",
    "    if(taille[0]!=taille[1]):\n",
    "        print(\"La matrice n'est pas carré\")\n",
    "        return L,U,False\n",
    "    \n",
    "    if(A[0,0]==0):\n",
    "        print(\"Matrice non completement régulière\")\n",
    "        return L,U,False\n",
    "        \n",
    "    i=1\n",
    "    #print(i)\n",
    "    i = i+1\n",
    "    a = A[0,0]\n",
    "    b = A[0,1:]\n",
    "    c = A[1:,0]\n",
    "    #A2 = [1:,0]\n",
    "    \n",
    "    U[0,:] = A[0,:]\n",
    "    L[1:,0] = A[1:,0]/a\n",
    "    L[1:,1:],U[1:,1:],ret = lu(A[1:,1:] - np.outer(L[1:,0],U[0,1:]))\n",
    "    \n",
    "    return L,U,ret"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matrice non completement régulière\n",
      "False\n",
      "[[1. 0. 0. 0.]\n",
      " [1. 1. 0. 0.]\n",
      " [1. 0. 1. 0.]\n",
      " [1. 0. 0. 1.]]\n",
      "[[1. 1. 1. 1.]\n",
      " [0. 0. 0. 0.]\n",
      " [0. 0. 0. 0.]\n",
      " [0. 0. 0. 0.]]\n",
      "[[1. 1. 1. 1.]\n",
      " [1. 1. 1. 1.]\n",
      " [1. 1. 1. 1.]\n",
      " [1. 1. 1. 1.]]\n"
     ]
    }
   ],
   "source": [
    "#lu(a2)\n",
    "T = np.array([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,0]])\n",
    "\n",
    "L,U,ret = lu(T)\n",
    "print(ret)\n",
    "print(L)\n",
    "print(U)\n",
    "print(L@U)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[2 2]\n",
      " [3 4]\n",
      " [3 4]]\n",
      "(3, 2)\n",
      "2\n",
      "3\n",
      "2\n",
      "[0]\n",
      "1\n",
      "(1,)\n",
      "[[0. 0. 0. 0. 0.]\n",
      " [0. 0. 0. 0. 0.]\n",
      " [0. 0. 0. 0. 0.]\n",
      " [0. 0. 0. 0. 0.]\n",
      " [0. 0. 0. 0. 0.]]\n"
     ]
    }
   ],
   "source": [
    "a = np.array([[2,2],[3,4],[3,4]])\n",
    "a2 = np.array([[2,2],[3,4]])\n",
    "print(a)\n",
    "b = np.shape(a)\n",
    "print(b)\n",
    "print(np.size(b))\n",
    "print(b[0])\n",
    "print(b[1])\n",
    "\n",
    "c = np.array([0])\n",
    "print(c)\n",
    "print(np.size(c))\n",
    "c2 = np.shape(c)\n",
    "print(c2)\n",
    "\n",
    "d = np.zeros((5,5))\n",
    "print(d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Question 3\n",
    "\n",
    "> Testez votre fonction `lu` en calculant et en affichant la décomposition de la matrice\n",
    "$$\n",
    "A = \\begin{pmatrix}\n",
    "3&2&1 \\\\ 6&5&4 \\\\ 9&8&10\n",
    "\\end{pmatrix}.\n",
    "$$\n",
    "\n",
    "Vous devriez trouver\n",
    "$$\n",
    "L = \\begin{pmatrix}\n",
    "1&0&0 \\\\ 2&1&0 \\\\ 3&2&1\n",
    "\\end{pmatrix}, \n",
    "\\qquad \n",
    "U = \\begin{pmatrix}\n",
    "3&2&1 \\\\ 0&1&2 \\\\ 0&0&3\n",
    "\\end{pmatrix}.\n",
    "$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 0 0]\n",
      " [2 1 0]\n",
      " [3 2 1]]\n",
      "[[3 2 1]\n",
      " [0 1 2]\n",
      " [0 0 3]]\n",
      "[[ 3  2  1]\n",
      " [ 6  5  4]\n",
      " [ 9  8 10]]\n",
      "[[1. 0. 0.]\n",
      " [2. 1. 0.]\n",
      " [3. 2. 1.]]\n",
      "[[3. 2. 1.]\n",
      " [0. 1. 2.]\n",
      " [0. 0. 3.]]\n"
     ]
    }
   ],
   "source": [
    "L = np.array([[1,0,0], [2,1,0], [3,2,1]])\n",
    "U = np.array([[3,2,1], [0,1,2], [0,0,3]])\n",
    "print(L)\n",
    "print(U)\n",
    "A = np.dot(L, U)\n",
    "print(A)\n",
    "L, U, retcode = lu(A)\n",
    "print(L)\n",
    "print(U)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Question 4\n",
    "\n",
    "> Construisez une matrice aléatoire de nombres entiers entre $-10$ et $10$ de taille $20$. Calculez ensuite la décomposition $LU$ si elle existe et vérifiez que vous avez bien $A=LU$.\n",
    "\n",
    "*Indication : vous pourrez penser à utiliser la fonction `randint` du package `numpy.random`*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[71 98 23 20 27]\n"
     ]
    }
   ],
   "source": [
    "?rd.randint\n",
    "a = rd.randint(0,100,size = 5,dtype = int)\n",
    "print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Question 5\n",
    "\n",
    "> Déterminez la décomposition $LU$ de la matrice du Laplacien renormalisée\n",
    "$$\n",
    "A = \\begin{pmatrix}\n",
    "2&-1&0&\\ldots&0\\\\\n",
    "-1&2&-1&\\ddots&\\vdots\\\\\n",
    "0&\\ddots&\\ddots&\\ddots&0\\\\\n",
    "\\vdots&\\ddots&-1&2&-1\\\\\n",
    "0&\\ldots&0&-1&2\n",
    "\\end{pmatrix}.\n",
    "$$\n",
    "> Vous testerez différentes valeurs de $n$ correspondant à la taille de la matrice."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 2. -1.  0.  0.  0.]\n",
      " [-1.  2. -1.  0.  0.]\n",
      " [ 0. -1.  2. -1.  0.]\n",
      " [ 0.  0. -1.  2. -1.]\n",
      " [ 0.  0.  0. -1.  2.]]\n",
      "walala [[ 2.         -1.          0.          0.          0.        ]\n",
      " [ 0.          1.5        -1.          0.          0.        ]\n",
      " [ 0.          0.          1.33333333 -1.          0.        ]\n",
      " [ 0.          0.          0.          1.25       -1.        ]\n",
      " [ 0.          0.          0.          0.          1.2       ]]\n"
     ]
    }
   ],
   "source": [
    "def mat_Laplacien(N):\n",
    "        \n",
    "    A = 2*np.eye(N,N) + (-1)*np.eye(N,N,-1) + (-1)*np.eye(N,N,1)\n",
    "            \n",
    "    return A\n",
    "\n",
    "A = mat_Laplacien(5)\n",
    "print(A)\n",
    "L,U,ret = lu(A)\n",
    "print(L,U)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "N =  1\n",
      "L = \n",
      "1\n",
      "U = \n",
      "[[2.]]\n",
      "N =  2\n",
      "L = \n",
      "[[ 1.   0. ]\n",
      " [-0.5  1. ]]\n",
      "U = \n",
      "[[ 2.  -1. ]\n",
      " [ 0.   1.5]]\n",
      "N =  3\n",
      "L = \n",
      "[[ 1.          0.          0.        ]\n",
      " [-0.5         1.          0.        ]\n",
      " [ 0.         -0.66666667  1.        ]]\n",
      "U = \n",
      "[[ 2.         -1.          0.        ]\n",
      " [ 0.          1.5        -1.        ]\n",
      " [ 0.          0.          1.33333333]]\n",
      "N =  4\n",
      "L = \n",
      "[[ 1.          0.          0.          0.        ]\n",
      " [-0.5         1.          0.          0.        ]\n",
      " [ 0.         -0.66666667  1.          0.        ]\n",
      " [ 0.          0.         -0.75        1.        ]]\n",
      "U = \n",
      "[[ 2.         -1.          0.          0.        ]\n",
      " [ 0.          1.5        -1.          0.        ]\n",
      " [ 0.          0.          1.33333333 -1.        ]\n",
      " [ 0.          0.          0.          1.25      ]]\n",
      "N =  5\n",
      "L = \n",
      "[[ 1.          0.          0.          0.          0.        ]\n",
      " [-0.5         1.          0.          0.          0.        ]\n",
      " [ 0.         -0.66666667  1.          0.          0.        ]\n",
      " [ 0.          0.         -0.75        1.          0.        ]\n",
      " [ 0.          0.          0.         -0.8         1.        ]]\n",
      "U = \n",
      "[[ 2.         -1.          0.          0.          0.        ]\n",
      " [ 0.          1.5        -1.          0.          0.        ]\n",
      " [ 0.          0.          1.33333333 -1.          0.        ]\n",
      " [ 0.          0.          0.          1.25       -1.        ]\n",
      " [ 0.          0.          0.          0.          1.2       ]]\n",
      "N =  6\n",
      "L = \n",
      "[[ 1.          0.          0.          0.          0.          0.        ]\n",
      " [-0.5         1.          0.          0.          0.          0.        ]\n",
      " [ 0.         -0.66666667  1.          0.          0.          0.        ]\n",
      " [ 0.          0.         -0.75        1.          0.          0.        ]\n",
      " [ 0.          0.          0.         -0.8         1.          0.        ]\n",
      " [ 0.          0.          0.          0.         -0.83333333  1.        ]]\n",
      "U = \n",
      "[[ 2.         -1.          0.          0.          0.          0.        ]\n",
      " [ 0.          1.5        -1.          0.          0.          0.        ]\n",
      " [ 0.          0.          1.33333333 -1.          0.          0.        ]\n",
      " [ 0.          0.          0.          1.25       -1.          0.        ]\n",
      " [ 0.          0.          0.          0.          1.2        -1.        ]\n",
      " [ 0.          0.          0.          0.          0.          1.16666667]]\n",
      "N =  7\n",
      "L = \n",
      "[[ 1.          0.          0.          0.          0.          0.\n",
      "   0.        ]\n",
      " [-0.5         1.          0.          0.          0.          0.\n",
      "   0.        ]\n",
      " [ 0.         -0.66666667  1.          0.          0.          0.\n",
      "   0.        ]\n",
      " [ 0.          0.         -0.75        1.          0.          0.\n",
      "   0.        ]\n",
      " [ 0.          0.          0.         -0.8         1.          0.\n",
      "   0.        ]\n",
      " [ 0.          0.          0.          0.         -0.83333333  1.\n",
      "   0.        ]\n",
      " [ 0.          0.          0.          0.          0.         -0.85714286\n",
      "   1.        ]]\n",
      "U = \n",
      "[[ 2.         -1.          0.          0.          0.          0.\n",
      "   0.        ]\n",
      " [ 0.          1.5        -1.          0.          0.          0.\n",
      "   0.        ]\n",
      " [ 0.          0.          1.33333333 -1.          0.          0.\n",
      "   0.        ]\n",
      " [ 0.          0.          0.          1.25       -1.          0.\n",
      "   0.        ]\n",
      " [ 0.          0.          0.          0.          1.2        -1.\n",
      "   0.        ]\n",
      " [ 0.          0.          0.          0.          0.          1.16666667\n",
      "  -1.        ]\n",
      " [ 0.          0.          0.          0.          0.          0.\n",
      "   1.14285714]]\n",
      "N =  8\n",
      "L = \n",
      "[[ 1.          0.          0.          0.          0.          0.\n",
      "   0.          0.        ]\n",
      " [-0.5         1.          0.          0.          0.          0.\n",
      "   0.          0.        ]\n",
      " [ 0.         -0.66666667  1.          0.          0.          0.\n",
      "   0.          0.        ]\n",
      " [ 0.          0.         -0.75        1.          0.          0.\n",
      "   0.          0.        ]\n",
      " [ 0.          0.          0.         -0.8         1.          0.\n",
      "   0.          0.        ]\n",
      " [ 0.          0.          0.          0.         -0.83333333  1.\n",
      "   0.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.         -0.85714286\n",
      "   1.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.          0.\n",
      "  -0.875       1.        ]]\n",
      "U = \n",
      "[[ 2.         -1.          0.          0.          0.          0.\n",
      "   0.          0.        ]\n",
      " [ 0.          1.5        -1.          0.          0.          0.\n",
      "   0.          0.        ]\n",
      " [ 0.          0.          1.33333333 -1.          0.          0.\n",
      "   0.          0.        ]\n",
      " [ 0.          0.          0.          1.25       -1.          0.\n",
      "   0.          0.        ]\n",
      " [ 0.          0.          0.          0.          1.2        -1.\n",
      "   0.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.          1.16666667\n",
      "  -1.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.          0.\n",
      "   1.14285714 -1.        ]\n",
      " [ 0.          0.          0.          0.          0.          0.\n",
      "   0.          1.125     ]]\n",
      "N =  9\n",
      "L = \n",
      "[[ 1.          0.          0.          0.          0.          0.\n",
      "   0.          0.          0.        ]\n",
      " [-0.5         1.          0.          0.          0.          0.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.         -0.66666667  1.          0.          0.          0.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.          0.         -0.75        1.          0.          0.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.          0.          0.         -0.8         1.          0.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.          0.          0.          0.         -0.83333333  1.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.         -0.85714286\n",
      "   1.          0.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.          0.\n",
      "  -0.875       1.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.          0.\n",
      "   0.         -0.88888889  1.        ]]\n",
      "U = \n",
      "[[ 2.         -1.          0.          0.          0.          0.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.          1.5        -1.          0.          0.          0.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.          0.          1.33333333 -1.          0.          0.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.          0.          0.          1.25       -1.          0.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.          0.          0.          0.          1.2        -1.\n",
      "   0.          0.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.          1.16666667\n",
      "  -1.          0.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.          0.\n",
      "   1.14285714 -1.          0.        ]\n",
      " [ 0.          0.          0.          0.          0.          0.\n",
      "   0.          1.125      -1.        ]\n",
      " [ 0.          0.          0.          0.          0.          0.\n",
      "   0.          0.          1.11111111]]\n"
     ]
    }
   ],
   "source": [
    "for i in range (1,10):\n",
    "    A = mat_Laplacien(i)\n",
    "    L,U,ret = lu(A)\n",
    "    print(\"N = \",i)\n",
    "    print(\"L = \"); print(L)\n",
    "    print(\"U = \");print(U)\n",
    "\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Question 5 bis\n",
    "\n",
    "Le défaut de l'algorithme précédent est qu'il fabrique beaucoup de matrices temporaires pour effectuer la décomposition $LU$.\n",
    "\n",
    "> Essayez (si vous avez le temps) de proposer une fonction optimisée qui gère mieux la mémoire en travaillant toujours sur le même tableau.\n",
    "> Vérifiez que cette fonction donne les mêmes résultats que la précédente."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Approche non récursive\n",
    "\n",
    "Reprenons l'algorithme déjà vu pour le calcul de la factorisation, afin de le mettre en pratique cette fois-ci de façon non récursive.\n",
    "\n",
    "#### Première étape :\n",
    "\n",
    "$$\n",
    "A = \\begin{pmatrix}\n",
    "a^{(1)} & b^{(1)} \\\\\n",
    "c^{(1)} & A^{(1)}\n",
    "\\end{pmatrix}\n",
    "= LU = \\begin{pmatrix}\n",
    "1 & 0 \\\\\n",
    "l^{(1)} & L^{(1)}\n",
    "\\end{pmatrix}\\begin{pmatrix}\n",
    "\\alpha^{(1)} & u^{(1)} \\\\ 0 & U^{(1)}\n",
    "\\end{pmatrix}\n",
    "= \\begin{pmatrix}\n",
    "\\alpha^{(1)} & u^{(1)} \\\\\n",
    "\\alpha^{(1)} l^{(1)} & l^{(1)} u^{(1)} + L^{(1)} U^{(1)}\n",
    "\\end{pmatrix}\n",
    "\\,,\n",
    "$$\n",
    "\n",
    "d'où le système de quatre équations matricielles\n",
    "\n",
    "$$\n",
    "\\left\\{\\begin{aligned}\n",
    "a^{(1)} & = \\alpha^{(1)} \\,,\\\\\n",
    "b^{(1)} & = u^{(1)} \\,,\\\\\n",
    "c^{(1)} & = \\alpha^{(1)} l^{(1)}\\,,\\\\\n",
    "A^{(1)} & = l^{(1)}u^{(1)} + L^{(1)} U^{(1)}\\,.\n",
    "\\end{aligned}\\right.\n",
    "$$\n",
    "\n",
    "Si la factorisation $LU$ de $A$ existe, la matrice $U$ ci-dessus devant être triangulaire et inversible, \n",
    "la condition $\\alpha^{(1)} \\neq 0$ est vérifiée. Le système impose alors successivement les valeurs de $\\alpha^{(1)}$, $u^{(1)}$ et $l^{(1)}$ en fonction des données $a^{(1)}$, $b^{(1)}$ et $c^{(1)}$, ce qui donne les valeurs \n",
    "de la première ligne de $U$ et de la première colonne de $L$. \n",
    "\n",
    "Reste alors à factoriser une matrice d'ordre $n-1$ :\n",
    "\n",
    "$$\n",
    "A^{(1)} - l^{(1)} u^{(1)} = L^{(1)}U^{(1)}\\,.\n",
    "$$\n",
    "\n",
    "#### $k-$ième étape :\n",
    "On cherche la factorisation \n",
    "\n",
    "$$\n",
    "A^{(k-1)} - l^{(k-1)}u^{(k-1)} = L^{(k-1)}U^{(k-1)}\\,.\n",
    "$$\n",
    "\n",
    "En décomposant par blocs :\n",
    "\n",
    "$$\n",
    "\\begin{pmatrix}\n",
    "a^{(k)} & b^{(k)} \\\\\n",
    "c^{(k)} & A^{(k)}\n",
    "\\end{pmatrix} \n",
    "= \\begin{pmatrix}\n",
    "1 & 0 \\\\\n",
    "l^{(k)} & L^{(k)}\n",
    "\\end{pmatrix}\\begin{pmatrix}\n",
    "\\alpha^{(k)} & u^{(k)} \\\\ 0 & U^{(k)}\n",
    "\\end{pmatrix}\n",
    "= \\begin{pmatrix}\n",
    "\\alpha^{(k)} & u^{(k)} \\\\\n",
    "\\alpha^{(k)} l^{(k)} & l^{(k)} u^{(k)} + L^{(k)} U^{(k)}\n",
    "\\end{pmatrix}\n",
    "\\,,\n",
    "$$\n",
    "\n",
    "d'où le système de quatre équations matricielles\n",
    "\n",
    "$$\n",
    "\\left\\{\\begin{aligned}\n",
    "a^{(k)} & = \\alpha^{(k)} \\,,\\\\\n",
    "b^{(k)} & = u^{(k)} \\,,\\\\\n",
    "c^{(k)} & = \\alpha^{(k)} l^{(k)}\\,,\\\\\n",
    "A^{(k)} & = l^{(k)}u^{(k)} + L^{(k)} U^{(k)}\\,.\n",
    "\\end{aligned}\\right.\n",
    "$$\n",
    "\n",
    "Si la factorisation $LU$ de $$A^{(k-1)}- l^{(k-1)}u^{(k-1)}$$ existe, la condition $\\alpha^{(k)} \\neq 0$ est vérifiée. Le système impose alors successivement les valeurs de $\\alpha^{(k)}$, $u^{(k)}$ et $l^{(k)}$ en fonction de $a^{(k)}$, $b^{(k)}$ et $c^{(k)}$, ce qui donne les valeurs de la première ligne de $U^{(k-1)}$ et de la première colonne de $L^{(k-1)}$, ou bien encore de la $k-$ième ligne de la matrice $U$ et la $k-$ième colonne de la matrice $L$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Question 6\n",
    "\n",
    "> Programmez une fonction non récursive `lu_nonrec` qui prend en argument une matrice $A$ et qui retourne la matrice $L$ et la matrice $U$ de la décomposition $LU$ de $A$ ainsi qu'un booléen qui est vrai si la décomposition est réussie et faux dans le cas contraire. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "def lu_nonrec(A):\n",
    "    n = np.shape(A)\n",
    "    L = np.eye(n)\n",
    "    U = np.zeros((n,n))\n",
    "    \n",
    "    B = A *1.0\n",
    "    \n",
    "    for i in range (n-1):\n",
    "        a = B[i,i]\n",
    "        if (a==0):\n",
    "            return L,U,False\n",
    "        \n",
    "        U[i,i] = a\n",
    "        U[i,i+1:] = B[i,i+1:]\n",
    "        L[i+1:]\n",
    "        L[i+1:,i] = B[i+1:,i]/a\n",
    "        B[i+1:,i+1:] -= np.outer(L[i+1:,i],U[i,i+1:])\n",
    "        \n",
    "    return L,U,True\n",
    "        \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0. 0.]\n",
      " [0. 0.]]\n",
      "(2, 2)\n"
     ]
    }
   ],
   "source": [
    "A = np.zeros([2,2])\n",
    "print(A)\n",
    "print(np.shape(A))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Résolution de systèmes linéaires\n",
    "\n",
    "#### Question 7\n",
    "\n",
    "> Programmez deux fonctions `solve_triu` et `solve_tril` qui prennent en arguments une matrice triangulaire $T$ (inférieure ou supérieure selon la fonction) et un vecteur $b$ et qui retourne la solution $x$ de $Tx=b$ lorsque cette solution existe. Si la solution n'existe pas, la fonction devra retourner un message explicite."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "def solve_triu(T,b):\n",
    "    n,p = T.shape\n",
    "    x = np.zeros(n)\n",
    "    x[n-1] = b[n-1]/T[n-1,n-1]\n",
    "    for i in range(2,n+1):\n",
    "        x[n-i] = x[n-(i-1)] + b[n-i]/T[n-i,n-1]\n",
    "    return x\n",
    "\n",
    "def solve_tril(T,b):\n",
    "    n,p = T.shape\n",
    "    x = np.zeros(n)\n",
    "    x[0] = b[0]/T[0,0]\n",
    "    for i in range(1,n):\n",
    "        x[i] = x[i-1] + b[i]/T[i,i]\n",
    "    return x\n",
    "\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Question 8\n",
    "\n",
    "> Programmez une fonction `solve` qui prend en argument une matrice $A$ et un vecteur $b$ et qui retourne la solution du système linéaire $Ax=b$ en utilisant la décomposition de la matrice $A$.\n",
    "\n",
    "> Lorsque la solution de ce système linéaire n'est pas trouvée (par exemple parce que la décomposition $LU$ n'existe pas), la fonction devra afficher un message explicite."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 2. -1.  0.  0.  0.]\n",
      " [-1.  2. -1.  0.  0.]\n",
      " [ 0. -1.  2. -1.  0.]\n",
      " [ 0.  0. -1.  2. -1.]\n",
      " [ 0.  0.  0. -1.  2.]]\n",
      "[[ 1.          0.          0.          0.          0.        ]\n",
      " [-0.5         1.          0.          0.          0.        ]\n",
      " [ 0.         -0.66666667  1.          0.          0.        ]\n",
      " [ 0.          0.         -0.75        1.          0.        ]\n",
      " [ 0.          0.          0.         -0.8         1.        ]]\n",
      "[[1. 0. 0. 0. 0.]\n",
      " [0. 1. 0. 0. 0.]\n",
      " [0. 0. 1. 0. 0.]\n",
      " [0. 0. 0. 1. 0.]\n",
      " [0. 0. 0. 0. 1.]]\n",
      "[[ 2.         -1.          0.          0.          0.        ]\n",
      " [ 0.          1.5        -1.          0.          0.        ]\n",
      " [ 0.          0.          1.33333333 -1.          0.        ]\n",
      " [ 0.          0.          0.          1.25       -1.        ]\n",
      " [ 0.          0.          0.          0.          1.2       ]]\n",
      "True\n"
     ]
    }
   ],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Question 9\n",
    "\n",
    "> Testez votre fonction `solve` en choisissant de manière aléatoire une matrice $A$ et un vecteur $b$ et en vérifiant que le vecteur obtenu est bien solution."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": []
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
